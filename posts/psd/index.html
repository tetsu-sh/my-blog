<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="128x128" href="/favicon/favicon-128.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32-32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16-16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon-32-32.png"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Markdown."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>phisolopy of software designを読んで</title><meta name="next-head-count" content="15"/><script src="https://embed.zenn.studio/js/listen-embed-event.js"></script><link rel="preload" href="/_next/static/css/f9647df309e85d16.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f9647df309e85d16.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-f6b251fbeee18b16.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-455fdf1d9b7b48bd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0f73896300543aa7.js" defer=""></script><script src="/_next/static/chunks/d0447323-452de5d02fa80e1c.js" defer=""></script><script src="/_next/static/chunks/831-17ae48e4ef21c306.js" defer=""></script><script src="/_next/static/chunks/358-bd79b5f955437da8.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-469f503d430feb30.js" defer=""></script><script src="/_next/static/hGE39SZNNWF4MnVWyBIZx/_buildManifest.js" defer=""></script><script src="/_next/static/hGE39SZNNWF4MnVWyBIZx/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><main><div class="flex min-h-screen flex-col"><header><nav class="fixed z-20 w-full bg-gray-700 py-3 text-center font-semibold" aria-label="Header navigation"><span class="test-xs px-5 text-neutral-200 hover:text-neutral-500 active:text-gray-600 transition duration-100">home</span><span class="test-xs text-neutral-200 hover:text-neutral-500 active:text-gray-600 transition duration-100">about</span></nav></header><div class="container mx-auto px-5"><div></div><div><div class="mt-16"><h1 class="text-5xl md:text-7xl lg:text-3xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left">phisolopy of software designを読んで</h1><div class="mb-6 text-lg"><time dateTime="2022-11-20T05:35:07.322Z">November	20, 2022</time></div><div class="max-w-2xl mx-auto"></div></div></div><div class="flex"><div class="article flex flex-col mx-10"><article class="mb-32 znc"><div class="post"><div class="markdown-styles_markdown__h_8de"><h2 id="%E3%81%BB%E3%82%93%E3%81%A8%E3%81%AB%E3%83%A1%E3%83%A2%E3%82%92%E7%AB%A0%E3%81%94%E3%81%A8%E3%81%AB"><a class="header-anchor-link" href="#%E3%81%BB%E3%82%93%E3%81%A8%E3%81%AB%E3%83%A1%E3%83%A2%E3%82%92%E7%AB%A0%E3%81%94%E3%81%A8%E3%81%AB" aria-hidden="true"></a> ほんとにメモを章ごとに</h2>
<ul>
<li>deepなモジュールを心がけろや、コメントあたりはためになった。</li>
<li>英語は比較的平易</li>
</ul>
<p>9 分けるべきかわけ無いべきかべきか</p>
<p>分けると複雑性を生む場合がある</p>
<p>クラス、インターフェースの数が多いと複雑性がます</p>
<p>同時に見れなくなる。最悪認識できない</p>
<p>コードの重複を生む</p>
<p>関連があるかどうか</p>
<p>情報を共有している</p>
<p>相互的に同時に使われる</p>
<p>一方通行なら分けるべき</p>
<p>概念が似ている</p>
<p>文字列検索と大文字小文字変換</p>
<p>まとめてみたいと理解できない一連のコード</p>
<p>9.1 まとめて情報を共有する。</p>
<p>9.2 インターフェースがシンプルになるなら、まとめる。まとめなかった時の知識がなくても使えるようになる</p>
<p>9.3 重複をまとめる</p>
<p>メソッドの呼び出しを巣にペットにする</p>
<p>9.4 汎用的なものと特化的なものを分ける</p>
<p>9.8 methodがdeepならより</p>
<p>親子関係だが相互を読む必要がない分割が良い</p>
<p>10</p>
<p>Erroの発生場所を抑えろ</p>
<p>問題ないならエラーをレイズしない</p>
<p>エラーに気づかないようにする。リトライ</p>
<p>Errorを汎用的にトップレベルにまとめる</p>
<p>クラッシュとは</p>
<p>特殊系のハンドリング</p>
<p>文字のセレクト機能</p>
<p>no selectという状態を持つのではなく、selectのstartとendが同じとすれば、特殊系を考慮しなくて良い設計となる。</p>
<p>何を知るべきか、隠すべきか考える</p>
<p>11　複数の選択肢を検討し、デザインしろ。interface,impl共に</p>
<p>12  comment</p>
<p>良いコードはドキュメントになるは嘘</p>
<p>抽象、deepなモジュールにはコメントは効果的な役割がある。ユーザーが使うとき、実装のときである。</p>
<p>cognitive load,unknown unknownを減らす</p>
<p>13 何を書くべきか</p>
<p>low:正確さをたすか（単位、境界値,nullの扱い、invariants(変数の条件)）、high:直感を促すコメント。コードとレベルを変えて、重複を避ける</p>
<p>コードで明らかでないことを書け.直感的にわかるように</p>
<p>変数は使い方ではなく、それが何かをドキュメンテーションしろ。</p>
<p>副作用や前提条件はコメントしろ。</p>
<p>interfaceなどのハイレベルでは実装に関して触れるな</p>
<p>読み手を想像しろ、読み手が混乱したらそれが真実、反論するな。</p>
<p>14 命名</p>
<p>理屈に通っているでは不十分。</p>
<p>block：fileblock,diskblockを混同してバグになった</p>
<p>コードを、ドキュメントを読まなくても名前だけで概念をイメージできるか</p>
<p>名前も抽象、具体は省く。</p>
<p>良い名前は正確かつ普遍。大体曖昧になっちゃう</p>
<p>命名が辛かったら、リファクタリングフラグだよっと</p>
<p>様々な箇所で使われても一定の意味を示すことが重要。コグにティブロード減らす</p>
<p>make sure that the purpose is narrow enough that all variables with the name have the same behavior.</p>
<p>15 先のコメント、ドキュメントをかけ</p>
<p>あとからだと設計思想を忘れる。</p>
<p>楽しくないから雑になる</p>
<p>余計な実装に引きづられず、大事なことがかける。開発中にコメントも改良していける</p>
<p>システムデザイン自体が良くなる。よくない設計に気付ける</p>
<p>16 改良</p>
<p>改良していくときも戦略的にやる必要がある。変更を最小にしがちだが、それは戦術的である。</p>
<p>modifieするときも常に良いデザインがないかリファクタリングの余地がないか考えながら、それのコストを払いながら行う</p>
<p>コメントもメンテしろ。コードの近くにコメントしろ。コミットログに書くな。</p>
<p>重複する場合はマスターコメントにしたり、リンクにしたりしろ</p>
<p>ハイレベルなコメントは些細な実装の変更の影響を受けるはずなくね？</p>
<p>17 一貫性</p>
<p>一貫性があると推測が立つし理解の手間が減るので、コグにティブロードやエンバグが減る</p>
<p>18 読みやすい</p>
<p>イベント駆動は呼ばれるところをインターフェースのコメントとかで書くと良い</p>
<p>ソフトウェアは描きやすい書き方より、読みやすい書き方であるべき。ジェネリックコンテなーは読みにくい</p>
<p>19 trend技術に関して</p>
<p>アジャイルは戦術的プログラミングになりやすい。設計より機能開発に走りやすく複雑さが築先する。抽象をインクリメントしろ</p>
<p>TDDもインクリメンタルで戦術的プログラミングになりやすい。抽象をデザインしろ</p>
<p>デザインパターンには肯定的</p>
<p>20 performanc</p>
<p>基本はファンダメンタルな部分がパフォーマンスに効く。キャッシュ、アルゴリズム、デーア構造、ネットワークなど</p>
<p>コードに手を入れなければならないのなら、理想を考えろ。既存のものは考えず、ミニマムでクリティカルなものだけ考え、データ構造やメソッドをまとめることをリデザインする</p>
</div></div></article></div><div class="aside-toc flex flex-col sticky"><aside></aside></div></div></div></div><style>
        .aside-toc{
          width:60%;
          position:sticky;
          top:20;
        }
        .article{
          width:100%
          position:relative;
        }
        </style></main></div><footer><div class="p-10 center bg-neutral-800"><div class="flex flex-col items-center gap-4"><div class="flex gap-4"><span class="text-neutral-200 hover:text-neutral-500 active:text-gray-600 transition duration-100" aria-label="Github" href="https://github.com/tetsu-sh"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></span><span class="text-neutral-200 hover:text-neutral-500 active:text-gray-600 transition duration-100" aria-label="Twitter" href="https://twitter.com/tetsu04228"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"></path></svg></span></div><div class="text-neutral-200 text-sm text-center">© <!-- -->2022<!-- --> Chimu</div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"phisolopy of software designを読んで","date":"2022-11-20T05:35:07.322Z","slug":"psd","content":"\u003ch2 id=\"%E3%81%BB%E3%82%93%E3%81%A8%E3%81%AB%E3%83%A1%E3%83%A2%E3%82%92%E7%AB%A0%E3%81%94%E3%81%A8%E3%81%AB\"\u003e\u003ca class=\"header-anchor-link\" href=\"#%E3%81%BB%E3%82%93%E3%81%A8%E3%81%AB%E3%83%A1%E3%83%A2%E3%82%92%E7%AB%A0%E3%81%94%E3%81%A8%E3%81%AB\" aria-hidden=\"true\"\u003e\u003c/a\u003e ほんとにメモを章ごとに\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003edeepなモジュールを心がけろや、コメントあたりはためになった。\u003c/li\u003e\n\u003cli\u003e英語は比較的平易\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e9 分けるべきかわけ無いべきかべきか\u003c/p\u003e\n\u003cp\u003e分けると複雑性を生む場合がある\u003c/p\u003e\n\u003cp\u003eクラス、インターフェースの数が多いと複雑性がます\u003c/p\u003e\n\u003cp\u003e同時に見れなくなる。最悪認識できない\u003c/p\u003e\n\u003cp\u003eコードの重複を生む\u003c/p\u003e\n\u003cp\u003e関連があるかどうか\u003c/p\u003e\n\u003cp\u003e情報を共有している\u003c/p\u003e\n\u003cp\u003e相互的に同時に使われる\u003c/p\u003e\n\u003cp\u003e一方通行なら分けるべき\u003c/p\u003e\n\u003cp\u003e概念が似ている\u003c/p\u003e\n\u003cp\u003e文字列検索と大文字小文字変換\u003c/p\u003e\n\u003cp\u003eまとめてみたいと理解できない一連のコード\u003c/p\u003e\n\u003cp\u003e9.1 まとめて情報を共有する。\u003c/p\u003e\n\u003cp\u003e9.2 インターフェースがシンプルになるなら、まとめる。まとめなかった時の知識がなくても使えるようになる\u003c/p\u003e\n\u003cp\u003e9.3 重複をまとめる\u003c/p\u003e\n\u003cp\u003eメソッドの呼び出しを巣にペットにする\u003c/p\u003e\n\u003cp\u003e9.4 汎用的なものと特化的なものを分ける\u003c/p\u003e\n\u003cp\u003e9.8 methodがdeepならより\u003c/p\u003e\n\u003cp\u003e親子関係だが相互を読む必要がない分割が良い\u003c/p\u003e\n\u003cp\u003e10\u003c/p\u003e\n\u003cp\u003eErroの発生場所を抑えろ\u003c/p\u003e\n\u003cp\u003e問題ないならエラーをレイズしない\u003c/p\u003e\n\u003cp\u003eエラーに気づかないようにする。リトライ\u003c/p\u003e\n\u003cp\u003eErrorを汎用的にトップレベルにまとめる\u003c/p\u003e\n\u003cp\u003eクラッシュとは\u003c/p\u003e\n\u003cp\u003e特殊系のハンドリング\u003c/p\u003e\n\u003cp\u003e文字のセレクト機能\u003c/p\u003e\n\u003cp\u003eno selectという状態を持つのではなく、selectのstartとendが同じとすれば、特殊系を考慮しなくて良い設計となる。\u003c/p\u003e\n\u003cp\u003e何を知るべきか、隠すべきか考える\u003c/p\u003e\n\u003cp\u003e11　複数の選択肢を検討し、デザインしろ。interface,impl共に\u003c/p\u003e\n\u003cp\u003e12  comment\u003c/p\u003e\n\u003cp\u003e良いコードはドキュメントになるは嘘\u003c/p\u003e\n\u003cp\u003e抽象、deepなモジュールにはコメントは効果的な役割がある。ユーザーが使うとき、実装のときである。\u003c/p\u003e\n\u003cp\u003ecognitive load,unknown unknownを減らす\u003c/p\u003e\n\u003cp\u003e13 何を書くべきか\u003c/p\u003e\n\u003cp\u003elow:正確さをたすか（単位、境界値,nullの扱い、invariants(変数の条件)）、high:直感を促すコメント。コードとレベルを変えて、重複を避ける\u003c/p\u003e\n\u003cp\u003eコードで明らかでないことを書け.直感的にわかるように\u003c/p\u003e\n\u003cp\u003e変数は使い方ではなく、それが何かをドキュメンテーションしろ。\u003c/p\u003e\n\u003cp\u003e副作用や前提条件はコメントしろ。\u003c/p\u003e\n\u003cp\u003einterfaceなどのハイレベルでは実装に関して触れるな\u003c/p\u003e\n\u003cp\u003e読み手を想像しろ、読み手が混乱したらそれが真実、反論するな。\u003c/p\u003e\n\u003cp\u003e14 命名\u003c/p\u003e\n\u003cp\u003e理屈に通っているでは不十分。\u003c/p\u003e\n\u003cp\u003eblock：fileblock,diskblockを混同してバグになった\u003c/p\u003e\n\u003cp\u003eコードを、ドキュメントを読まなくても名前だけで概念をイメージできるか\u003c/p\u003e\n\u003cp\u003e名前も抽象、具体は省く。\u003c/p\u003e\n\u003cp\u003e良い名前は正確かつ普遍。大体曖昧になっちゃう\u003c/p\u003e\n\u003cp\u003e命名が辛かったら、リファクタリングフラグだよっと\u003c/p\u003e\n\u003cp\u003e様々な箇所で使われても一定の意味を示すことが重要。コグにティブロード減らす\u003c/p\u003e\n\u003cp\u003emake sure that the purpose is narrow enough that all variables with the name have the same behavior.\u003c/p\u003e\n\u003cp\u003e15 先のコメント、ドキュメントをかけ\u003c/p\u003e\n\u003cp\u003eあとからだと設計思想を忘れる。\u003c/p\u003e\n\u003cp\u003e楽しくないから雑になる\u003c/p\u003e\n\u003cp\u003e余計な実装に引きづられず、大事なことがかける。開発中にコメントも改良していける\u003c/p\u003e\n\u003cp\u003eシステムデザイン自体が良くなる。よくない設計に気付ける\u003c/p\u003e\n\u003cp\u003e16 改良\u003c/p\u003e\n\u003cp\u003e改良していくときも戦略的にやる必要がある。変更を最小にしがちだが、それは戦術的である。\u003c/p\u003e\n\u003cp\u003emodifieするときも常に良いデザインがないかリファクタリングの余地がないか考えながら、それのコストを払いながら行う\u003c/p\u003e\n\u003cp\u003eコメントもメンテしろ。コードの近くにコメントしろ。コミットログに書くな。\u003c/p\u003e\n\u003cp\u003e重複する場合はマスターコメントにしたり、リンクにしたりしろ\u003c/p\u003e\n\u003cp\u003eハイレベルなコメントは些細な実装の変更の影響を受けるはずなくね？\u003c/p\u003e\n\u003cp\u003e17 一貫性\u003c/p\u003e\n\u003cp\u003e一貫性があると推測が立つし理解の手間が減るので、コグにティブロードやエンバグが減る\u003c/p\u003e\n\u003cp\u003e18 読みやすい\u003c/p\u003e\n\u003cp\u003eイベント駆動は呼ばれるところをインターフェースのコメントとかで書くと良い\u003c/p\u003e\n\u003cp\u003eソフトウェアは描きやすい書き方より、読みやすい書き方であるべき。ジェネリックコンテなーは読みにくい\u003c/p\u003e\n\u003cp\u003e19 trend技術に関して\u003c/p\u003e\n\u003cp\u003eアジャイルは戦術的プログラミングになりやすい。設計より機能開発に走りやすく複雑さが築先する。抽象をインクリメントしろ\u003c/p\u003e\n\u003cp\u003eTDDもインクリメンタルで戦術的プログラミングになりやすい。抽象をデザインしろ\u003c/p\u003e\n\u003cp\u003eデザインパターンには肯定的\u003c/p\u003e\n\u003cp\u003e20 performanc\u003c/p\u003e\n\u003cp\u003e基本はファンダメンタルな部分がパフォーマンスに効く。キャッシュ、アルゴリズム、デーア構造、ネットワークなど\u003c/p\u003e\n\u003cp\u003eコードに手を入れなければならないのなら、理想を考えろ。既存のものは考えず、ミニマムでクリティカルなものだけ考え、データ構造やメソッドをまとめることをリデザインする\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"psd"},"buildId":"hGE39SZNNWF4MnVWyBIZx","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>